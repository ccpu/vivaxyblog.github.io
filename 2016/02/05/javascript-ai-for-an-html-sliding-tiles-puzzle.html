<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <link rel="shortcut icon" href="/css/vivaxy.icon.png">
    <link type="text/css" rel="stylesheet" href="/css/reset.css">
    <link type="text/css" rel="stylesheet" href="/css/main.css">
    <link type="text/css" rel="stylesheet" href="/css/syntax.css">
    <link rel="alternate" type="application/atom+xml" title="vivaxy blog" href="/atom.xml"/>
    <title>用 Javascript 编写基于 HTML 的数字推盘游戏的 AI</title>
</head>
<body>
<div class="container">
    <a href="/" class="card hover-left">
    <div class="content">
        <h1>用 Javascript 编写基于 HTML 的数字推盘游戏的 AI</h1>
        <div class="date">2016-02-05</div>
    </div>
    <div class="icon-arrow-left"></div>
</a>
<div class="card">
    <div class="content">
        <p>本文翻译自 <a href="https://www.smashingmagazine.com/2016/02/javascript-ai-html-sliding-tiles-puzzle/">JavaScript AI For An HTML Sliding Tiles Puzzle By Arnaldo Perez Castano</a> 。</p>

<p>Sam Loud (1841 - 1911) 美国国际象棋手，智力游戏设计师，在1870年代发明了数字推盘游戏。这个游戏由 m 行 n 列的网格组成，每个格子可以是任何有规律的事物，比如数字，字母，图片等。</p>

<p>游戏的解答过程是将一个排布变成另一个排布，即从初始状态到目标状态。重新排序的方式是将空的格子和它边上的格子通过上下左右四个方向的交换来完成的。</p>

<p><img src="" alt=""></p>

<p>空的格子不能被移除出边框，因此如果它在第一列的话，空格不能往左移动；如果它在最右边的一列的话，它就不能再往右移动了。行的规定也是类似的。解的过程是这样的：</p>

<p><img src="" alt=""></p>

<p>这是开局。</p>

<p><img src="" alt=""></p>

<p>这样就算解出了。</p>

<p>只要验证左边的排布和右边的目标排布是一样的就可以判断是否完成了。</p>

<p>本文将分两个部分。第一部分会简要解释<em>怎么编写一个推盘游戏</em>，用 html, css 实现显示部分，然后用 javascript 来移动盘上的滑块。这部分同时也用在下一部分的文章中。</p>

<p>文章的第二部分，我们会用A*算法来开发一个人工智能，用来解决推盘游戏，计算解答游戏的最小步数。A*算法的多种启发式会给寻找解法带来很多帮助，启发式越智能，那么就能越快找到最优解法。启发式会按照智能程度由低到高，因此最后的启发式将是最强大的。</p>

<h2>布局</h2>

<p>首先我们创建一个空项目，包含一个 html 文件和一个 css 文件。分别是： <code>index.html</code> 和 <code>index.css</code> 。</p>

<p>引入 <code>jquery.js</code> 为了让生活更美好，写出更加简洁优雅的代码。（译者注：此处的文件名按照本人习惯稍作改动）</p>

<p>html 文件的头部如下：</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">&quot;Content-Type&quot;</span> <span class="na">content=</span><span class="s">&quot;text/html; charset=UTF-8&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content=</span><span class="s">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">type=</span><span class="s">&quot;image/png&quot;</span> <span class="na">rel=</span><span class="s">&quot;shortcut icon&quot;</span> <span class="na">href=</span><span class="s">&quot;/vivaxy.icon.png&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">type=</span><span class="s">&quot;text/css&quot;</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href=</span><span class="s">&quot;index.css&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>Sliding Tiles Puzzle<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
</code></pre></div>
<p>为了页面的性能，我们把js都放在页面底端。这是常见的做法，因为页面渲染是由上至下的，我们希望页面上的元素先显示，因此把用来交互的js文件放在页面最下方。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;body&gt;</span>

<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;js/jquery.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;js/priority-queue.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;js/hash-table.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;js/hash-set.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;js/index.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div>
<p><code>priority-queue.js</code>, <code>hash-table.js</code>, <code>hash-set.js</code> 是用来编写人工智能的，分别是用来存放队列，哈希表和哈希对的。</p>

<p>现在我们开始写html上的布局。首先，布局的框架是这样的。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;container&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;panel&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
</code></pre></div>
<p><code>container</code>容器这个类选择器在 <code>index.css</code> 文件中是这样的</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="c">/*</span>
<span class="c">Developed by Arnaldo Perez Castano</span>
<span class="c">arnaldo.skywalker@gmail.com</span>
<span class="c">*/</span>
<span class="nc">.container</span> <span class="p">{</span>
    <span class="k">width</span><span class="o">:</span> <span class="m">1024px</span><span class="p">;</span>
    <span class="k">margin-left</span><span class="o">:</span> <span class="k">auto</span><span class="p">;</span>
    <span class="k">margin-right</span><span class="o">:</span> <span class="k">auto</span><span class="p">;</span>
    <span class="k">min-height</span><span class="o">:</span> <span class="m">380px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>panel是在页面上打印显示人工智能的日志和结果的。</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.panel</span> <span class="p">{</span>
    <span class="k">width</span><span class="o">:</span> <span class="m">100%</span><span class="p">;</span>
    <span class="k">background-color</span><span class="o">:</span> <span class="k">rgb</span><span class="p">(</span><span class="m">180</span><span class="o">,</span> <span class="m">180</span><span class="o">,</span> <span class="m">180</span><span class="p">);</span>
    <span class="k">min-height</span><span class="o">:</span> <span class="m">1000px</span><span class="p">;</span>
    <span class="k">color</span><span class="o">:</span> <span class="nb">white</span><span class="p">;</span>
    <span class="k">font-weight</span><span class="o">:</span> <span class="k">bold</span><span class="p">;</span>
    <span class="k">padding</span><span class="o">:</span> <span class="m">5px</span><span class="p">;</span>
    <span class="k">font-family</span><span class="o">:</span> <span class="n">Arial</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>我们希望容器在页面中间，所以需要给它设置宽度，并且把它的 <code>margin-left</code> 和 <code>margin-right</code> 设置为 <code>auto</code>。</p>

<p>现在我们在 container 中加入 <code>grid-container</code> ，用来显示推盘的网格。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;container&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;grid-container&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;h2&gt;</span> Initial Config <span class="nt">&lt;/h2&gt;</span>

    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p><code>grid-container</code> 和它下面的元素的样式如下所示。</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.grid-container</span> <span class="p">{</span>
    <span class="k">float</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span>
    <span class="k">height</span><span class="o">:</span> <span class="m">250px</span><span class="p">;</span>
    <span class="k">text-align</span><span class="o">:</span> <span class="k">center</span><span class="p">;</span>
    <span class="k">width</span><span class="o">:</span> <span class="m">50%</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.grid-container</span> <span class="nt">h2</span> <span class="p">{</span>
    <span class="k">font-family</span><span class="o">:</span> <span class="n">Tahoma</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>我们把网格容器左浮动，因为两个同样的容器要显示在一行，一个是用来显示初始布局的，另一个是用来显示目标布局的。</p>

<p>最后，我们的网格是这个样子的。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;grid-container&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h2&gt;</span> Initial Config <span class="nt">&lt;/h2&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;grid start&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;row&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;0,0&quot;</span><span class="nt">&gt;&lt;span&gt;</span>6<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;0,1&quot;</span><span class="nt">&gt;&lt;span&gt;</span>4<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;0,2&quot;</span><span class="nt">&gt;&lt;span&gt;</span>7<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;row&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;1,0&quot;</span><span class="nt">&gt;&lt;span&gt;</span>8<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;1,1&quot;</span><span class="nt">&gt;&lt;span&gt;</span>5<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">id=</span><span class="s">&quot;empty&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;1,2&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;row&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;2,0&quot;</span><span class="nt">&gt;&lt;span&gt;</span>3<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;2,1&quot;</span><span class="nt">&gt;&lt;span&gt;</span>2<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span> <span class="na">data-pos=</span><span class="s">&quot;2,2&quot;</span><span class="nt">&gt;&lt;span&gt;</span>1<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>推盘游戏有三行，每行有三个滑块，这就组成了整个推盘网格。于是我们使用了以上布局，三个行容器，每个行容器有三个子元素，每个子元素是一个滑块。</p>

<p>为了编程方便，我们在每个子元素上添加了 <code>data-pos</code> 这个属性，为了记录每个滑块在网格中的位置。 <code>start</code> 这个类名是为了区分初始布局的网格和目标布局的网格，后者不会绑定用户操作。以上几个类的样式如下。</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.grid</span> <span class="p">{</span>
    <span class="k">background-color</span><span class="o">:</span> <span class="k">rgb</span><span class="p">(</span><span class="m">248</span><span class="o">,</span> <span class="m">248</span><span class="o">,</span> <span class="m">248</span><span class="p">);</span>
    <span class="k">border</span><span class="o">:</span> <span class="k">solid</span> <span class="m">5px</span> <span class="k">rgb</span><span class="p">(</span><span class="m">249</span><span class="o">,</span> <span class="m">90</span><span class="o">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="k">width</span><span class="o">:</span> <span class="m">210px</span><span class="p">;</span>
    <span class="k">height</span><span class="o">:</span> <span class="m">210px</span><span class="p">;</span>
    <span class="k">margin-left</span><span class="o">:</span> <span class="k">auto</span><span class="p">;</span>
    <span class="k">margin-right</span><span class="o">:</span> <span class="k">auto</span><span class="p">;</span>
    <span class="k">border</span><span class="o">-</span><span class="n">radius</span><span class="o">:</span> <span class="m">3px</span><span class="p">;</span>
    <span class="n">box</span><span class="o">-</span><span class="n">shadow</span><span class="o">:</span> <span class="m">5px</span> <span class="m">5px</span> <span class="m">#d8d8d8</span><span class="o">,</span> <span class="m">5px</span> <span class="m">5px</span> <span class="m">#d8d8d8</span><span class="p">;</span>
    <span class="k">overflow</span><span class="o">:</span> <span class="k">auto</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.row</span> <span class="p">{</span>
    <span class="k">height</span><span class="o">:</span> <span class="m">33.3%</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.cell</span> <span class="p">{</span>
    <span class="k">width</span><span class="o">:</span> <span class="m">33.3%</span><span class="p">;</span>
    <span class="k">height</span><span class="o">:</span> <span class="m">100%</span><span class="p">;</span>
    <span class="k">float</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span>
    <span class="k">text-align</span><span class="o">:</span> <span class="k">center</span><span class="p">;</span>
    <span class="k">font-size</span><span class="o">:</span> <span class="m">150%</span><span class="p">;</span>
    <span class="k">font-family</span><span class="o">:</span> <span class="n">Arial</span><span class="p">;</span>
    <span class="k">font-weight</span><span class="o">:</span> <span class="k">bold</span><span class="p">;</span>
    <span class="k">position</span><span class="o">:</span> <span class="k">relative</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.cell</span><span class="nd">:hover</span> <span class="p">{</span>
    <span class="k">background-color</span><span class="o">:</span> <span class="k">rgb</span><span class="p">(</span><span class="m">221</span><span class="o">,</span> <span class="m">221</span><span class="o">,</span> <span class="m">221</span><span class="p">);</span>
<span class="p">}</span>

<span class="nc">.cell</span> <span class="nt">span</span> <span class="p">{</span>
    <span class="k">display</span><span class="o">:</span> <span class="k">block</span><span class="p">;</span>
    <span class="n">transform</span><span class="o">:</span> <span class="n">translateY</span><span class="p">(</span><span class="m">70%</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>最后结果如下</p>

<p><img src="" alt=""></p>

<p>最后的网格</p>

<p>接下来我们把目标布局放上去，我们复制一下起始布局，把上面的 <code>start</code> 改成 <code>goal</code> 就行了。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;grid-container&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h2&gt;</span> Goal Config <span class="nt">&lt;/h2&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;grid goal&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;row&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;span&gt;</span>1<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;span&gt;</span>2<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;span&gt;</span>3<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;row&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;span&gt;</span>4<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;span&gt;</span>5<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;span&gt;</span>6<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;row&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;span&gt;</span>7<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;span&gt;</span>8<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;cell&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p><img src="" alt=""></p>

<p>起始布局和目标布局</p>

<p>最后，我们把 <code>解答</code> 和 <code>显示步数</code> 这两个按钮加到第一个布局的容器中。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">&quot;start()&quot;</span><span class="nt">&gt;</span> Solve <span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">&quot;showSolution()&quot;</span><span class="nt">&gt;</span> Show Step <span class="nt">&lt;/button&gt;</span>
</code></pre></div>
<p>第一个按钮会执行自动计算，也就是 A* 算法。第二个按钮会显示自动计算的一步。所以，按第二个按钮多次之后我们就得到这个推盘游戏的最优解法了。</p>

<p>我们已经把所有界面展示部分完成了，那么我们开始写一些功能模块的部分。我们现在要让这个游戏能动起来，其实就是要让空白的滑块能够在整个推盘中移动。我们用 javascript 来实现这个功能。 <code>index.js</code> 文件的前几行如下：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="cm">/*</span>
<span class="cm">   Developed by Arnaldo Perez Castano</span>
<span class="cm">   arnaldo.skywalker@gmail.com</span>
<span class="cm">*/</span>

<span class="kd">var</span> <span class="nx">emptytilePosRow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">emptytilePosCol</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">cellDisplacement</span> <span class="o">=</span> <span class="s2">&quot;69px&quot;</span><span class="p">;</span>
</code></pre></div>
<p><code>emptytilePosRow</code> 和 <code>emptytilePosCol</code> 这两个变量会保存空白滑块所处的位置。每次移动的时候，都会改变。</p>

<p><code>cellDisplacement</code> 这个变量用来记录这个滑块在动画执行过程中所移动的距离。<code>cell</code> 这个类所在的 <code>div</code> 的 <code>position</code> 是 <code>relative</code> 。所以我们用 <code>top</code> 和 <code>right</code> 这两个属性来实现动画效果。 <code>cellDisplacement</code> 变量会记录下 <code>top</code> 和 <code>right</code> 的最新的值，来实现滑块的移动。</p>

<p>用来实现移动的方法如下：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">moveTile</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Gets the position of the current element</span>
    <span class="kd">var</span> <span class="nx">pos</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-pos&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">posRow</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">pos</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="kd">var</span> <span class="nx">posCol</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">pos</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div>
<p>请看，我们已经用上 jquery 来选择元素了。还要注意我们要用 <code>start</code> 这个类来让我们选择的都是初始布局中的元素，来保证目标布局不变。然后，我们拿到选中的滑块的位置。位置是用 <code>x,y</code> 这种形式存的。然后我们拿到了行和列的值，存在 <code>posRow</code> 和 <code>posCol</code> 这两个变量中。</p>

<p>接下来的代码是用来执行移动的。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// Move Up</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">posRow</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nx">emptytilePosRow</span> <span class="o">&amp;&amp;</span> <span class="nx">posCol</span> <span class="o">==</span> <span class="nx">emptytilePosCol</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">animate</span><span class="p">({</span>
        <span class="s1">&#39;top&#39;</span><span class="o">:</span> <span class="s2">&quot;+=&quot;</span> <span class="o">+</span> <span class="nx">cellDisplacement</span> <span class="c1">//moves up</span>
    <span class="p">});</span>

    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#empty&#39;</span><span class="p">).</span><span class="nx">animate</span><span class="p">({</span>
        <span class="s1">&#39;top&#39;</span><span class="o">:</span> <span class="s2">&quot;-=&quot;</span> <span class="o">+</span> <span class="nx">cellDisplacement</span> <span class="c1">//moves down</span>
    <span class="p">});</span>

    <span class="nx">emptytilePosRow</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-pos&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">posRow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nx">posCol</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Move Down</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">posRow</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="nx">emptytilePosRow</span> <span class="o">&amp;&amp;</span> <span class="nx">posCol</span> <span class="o">==</span> <span class="nx">emptytilePosCol</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">animate</span><span class="p">({</span>
        <span class="s1">&#39;top&#39;</span><span class="o">:</span> <span class="s2">&quot;-=&quot;</span> <span class="o">+</span> <span class="nx">cellDisplacement</span> <span class="c1">//moves down</span>
    <span class="p">});</span>

    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#empty&#39;</span><span class="p">).</span><span class="nx">animate</span><span class="p">({</span>
        <span class="s1">&#39;top&#39;</span><span class="o">:</span> <span class="s2">&quot;+=&quot;</span> <span class="o">+</span> <span class="nx">cellDisplacement</span> <span class="c1">//moves up</span>
    <span class="p">});</span>

    <span class="nx">emptytilePosRow</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-pos&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">posRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nx">posCol</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Move Left</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">posRow</span> <span class="o">==</span> <span class="nx">emptytilePosRow</span> <span class="o">&amp;&amp;</span> <span class="nx">posCol</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nx">emptytilePosCol</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">animate</span><span class="p">({</span>
        <span class="s1">&#39;right&#39;</span><span class="o">:</span> <span class="s2">&quot;-=&quot;</span> <span class="o">+</span> <span class="nx">cellDisplacement</span> <span class="c1">//moves right</span>
    <span class="p">});</span>

    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#empty&#39;</span><span class="p">).</span><span class="nx">animate</span><span class="p">({</span>
        <span class="s1">&#39;right&#39;</span><span class="o">:</span> <span class="s2">&quot;+=&quot;</span> <span class="o">+</span> <span class="nx">cellDisplacement</span> <span class="c1">//moves left</span>
    <span class="p">});</span>

    <span class="nx">emptytilePosCol</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-pos&#39;</span><span class="p">,</span> <span class="nx">posRow</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">posCol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Move Right</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">posRow</span> <span class="o">==</span> <span class="nx">emptytilePosRow</span> <span class="o">&amp;&amp;</span> <span class="nx">posCol</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="nx">emptytilePosCol</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">animate</span><span class="p">({</span>
        <span class="s1">&#39;right&#39;</span><span class="o">:</span> <span class="s2">&quot;+=&quot;</span> <span class="o">+</span> <span class="nx">cellDisplacement</span> <span class="c1">//moves left</span>
    <span class="p">});</span>

    <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#empty&#39;</span><span class="p">).</span><span class="nx">animate</span><span class="p">({</span>
        <span class="s1">&#39;right&#39;</span><span class="o">:</span> <span class="s2">&quot;-=&quot;</span> <span class="o">+</span> <span class="nx">cellDisplacement</span> <span class="c1">//moves right</span>
    <span class="p">});</span>

    <span class="nx">emptytilePosCol</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-pos&#39;</span><span class="p">,</span> <span class="nx">posRow</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">posCol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Update empty position</span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#empty&#39;</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-pos&#39;</span><span class="p">,</span> <span class="nx">emptytilePosRow</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nx">emptytilePosCol</span><span class="p">);</span>
</code></pre></div>
<p>每个 <code>if</code> 语句表示不同的移动方向。他们开起来差不多，只是条件，移动方向和更新的变量不同而已。比如向右移动，要看空的滑块是不是在当前移动的滑块的左边：<code>posRow === emptytilePosRow</code> 表示在一行，<code>posCol - 1 == emptytileCol</code> 表示空白的滑块在当前移动的滑块的左边一列。</p>

<p>如果条件满足，则执行 jquery 的动画，我们改变 <code>right</code> 属性的值，来移动当前选中的滑块。<code>if</code> 的条件语句的最后，我们修改 <code>emptytilePosCol</code> 的值，在其原来的值上加1，因为空白的滑块向右移动了一格。同时我们修改当前移动的滑块的位置的值，列数减1。最后我们改变空白滑块的位置。</p>

<h2>人工智能</h2>

<p>A* 搜寻算法（ Hart 等人在1968年提出）是用来计算多节点路径中两点之间最短距离的算法。我们用它来开发解答滑块游戏的功能。一个人工智能是能够在某种环境下按照特定的规则完成特定的任务的一种工具。最终的解法将有人工执行这个工具通过正确的决策来寻找。</p>

<p>人类在大部分情况下是理性的。一个人会根据所处环境的不同，从环境中得到信息，来对特定的情况采取理性的行为。比如在寒冷的冬天，我们会感到寒冷，于是我们会穿上厚厚的外套。</p>

<p>在滑块游戏这个场景下，环境是由整个板子决定的。滑块游戏的规则决定某个滑块能够向某个方向移动。如果该搜寻算法是有效的话，那么在一定的移动步数后，滑块的布局会变成目标布局。</p>

<h2>A* 搜寻算法能做什么</h2>

<p>A* 搜寻算法能够找到从一种空间布局到另一种空间布局转换方法。搜寻是否智能是根据转换过程中操作的步数来判断的，步数越少，算法越智能。为了能方便描述布局状态，我们把问题转换成图形。我们认为状态B是状态A的下一种状态，也就是说要到状态B就要先到状态A，由状态A通过移动一个滑块就能够到达状态B了。所以一个状态节点会有如下的四中子状态节点。</p>

<p><img src="" alt=""></p>

<p>A* 算法下节点示意图</p>

<p>A* 搜寻算法基本思路是根据外界环境来选择下一步的行为。外界环境是由数字组成的。假设状态为s，那么</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">f(s) = g(s) + h(s)
</code></pre></div>
<p>其中 g(s) 是从初始状态到状态s的总步数，h(s) 是从状态s到目标状态的总步数，所以总步数是 f(s) 。</p>

<p><img src="" alt=""></p>

<p>从其实状态到目标状态的总步数</p>

<p>我们使用启发式来寻找这巨大可能中的情况。启发式是一种载体，我们可以通过它将我们的经验和特定环境传递到人工智能算法中去，也就是传递到A*算法中去。通过启发式，我们就能找到解答问题的最短的途径了。</p>

<p>既然我们已经把问题转换成图像了，那么A* 算法的大概框架就变得和BFS算法（广度优先算法）差不多了。BFS 算法是一种经典的图形节点算法。 A* 算法和 BFS 算法的区别在于， A* 算法中下一环节开始计算的节点的选择是和 f(s) 的值关联的，会优先选择最短的 f(s) 来优先计算 ，但是在 BFS 算法中，所有节点的选择权重都是 1 ，所以哪个路径更短并没有任何影响，在 BFS 算法中，下一环节的计算会从先记录的节点开始，也就是先进先出（FIFO）的队列原则。</p>

<p>我们建立启发式的时候，一定要保证其中包含了所有关键信息。不知道这段是什么意思。不过大概说了要有个条件让A*算法能找到最优解，类似于函数收敛则能找到极值。</p>

<p>前面说到我们要用javascript来写人工智能，有些人大概会认为这是不明智的，不过后面我会证明javascript拥有足够的能力。我们先写一个 <code>Node</code> 对象。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">Node</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">emptyRow</span><span class="p">,</span> <span class="nx">emptyCol</span><span class="p">,</span> <span class="nx">depth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">state</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">emptyCol</span> <span class="o">=</span> <span class="nx">emptyCol</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">emptyRow</span> <span class="o">=</span> <span class="nx">emptyRow</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">depth</span> <span class="o">=</span> <span class="nx">depth</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">strRepresentation</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="c1">// String representation of the state in CSV format</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We assume the state is a square</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">state</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">state</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;Number of rows differs from number of columns&#39;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">state</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">strRepresentation</span> <span class="o">+=</span> <span class="nx">state</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>每个变量的说明如下：</p>

<ul>
<li><p><code>value</code> f(s) 的值</p></li>
<li><p><code>state</code> 用二维数组保存滑块排布的状态</p></li>
<li><p><code>emptyCol</code> 记录空滑块所在的列</p></li>
<li><p><code>emptyRow</code> 记录空滑块所在的行</p></li>
<li><p><code>depth</code> 记录从起始状态到现在的步数</p></li>
<li><p><code>strRepresentation</code> CSV 字符串的形式保存滑块布局的状态。比如目标布局的值是 1,2,3,4,5,6,7,8 。滑块游戏布局是一个可以循环的游戏，也就是说从状态 s 经过一定的移动可以回到状态 s 。因此我们需要记录下每步的布局来避免走重复的路。这里我们会用 HashSet 。</p></li>
<li><p><code>path</code> 记录每步的移动，用 DLRU 。这个字符串保存的是从其实布局到当前布局走过的路。</p></li>
<li><p><code>size</code> 滑块游戏网格的大小，我们假设网格是 n 乘以 m 的，n 等于 m 。</p></li>
</ul>

<p>现在我们有了 Node 这个对象，我们来用个例子演示一下使用 A* 算法解题的过程。我们用最简单的启发式，根据放错位置的滑块的个数来。错位启发式返回的值就是不在自己应该在的位置的滑块的个数。这里说明了这个启发式是可接受的。</p>

<p><img src="" alt=""></p>

<p>A* 搜寻算法</p>

<p>下面我们来实现 A* 算法：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">AStar</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">initial</span><span class="p">,</span> <span class="nx">goal</span><span class="p">,</span> <span class="nx">empty</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">initial</span> <span class="o">=</span> <span class="nx">initial</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">goal</span> <span class="o">=</span> <span class="nx">goal</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">empty</span> <span class="o">=</span> <span class="nx">empty</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PriorityQueue</span><span class="p">({</span>
        <span class="nx">comparator</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="nx">initial</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">HashSet</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div>
<p>上面我们以及功能使用了之前定义的数据结构。优先队列中我们定义了一种排序方法，我们会把 f(s) 较小的状态放在前面。哈希对中存放 <code>strRepresentation</code> 记录所有到达过的状态，来避免重复。</p>

<p>现在我们用原型链给 A* 算法添加方法。 原型链 <code>prototype</code> 是一种方法或者属性，在创建新对象实例时，这个方法或者属性会成为新实例的一部分。比如， <code>execute</code> 这个方法会在所有 <code>AStar</code> 对象中存在。</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">AStar</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">execute</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Add current state to visited list</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">initial</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">dequeue</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">current</span><span class="p">.</span><span class="nx">strRepresentation</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">goal</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">current</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">expandNode</span><span class="p">(</span><span class="nx">current</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p><code>execute</code> 方法在以下几点上像 BFS ：</p>

<ul>
<li><p>有循环，循环结束于优先队列结束后。</p></li>
<li><p>当前的变量存放的是队列中的最小值。</p></li>
<li><p>如果节点的状态与目标状态匹配的话，那么我们认为整个搜寻任务结束。</p></li>
<li><p>如果搜寻任务没有结束，那么我们会对当前的节点进行展开。也就是在当点状态下执行每个方向的移动，然后把新的节点添加到队列中。</p></li>
</ul>

<p>对节点展开的方法如下：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">AStar</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">expandNode</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">temp</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">newState</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">col</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">emptyCol</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">emptyRow</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="c1">// Up</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">row</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">newState</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
        <span class="nx">temp</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">col</span><span class="p">];</span>
        <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">empty</span><span class="p">;</span>
        <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">newState</span><span class="p">,</span> <span class="nx">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">newNode</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">depth</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">heuristic</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
            <span class="nx">newNode</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">path</span> <span class="o">+</span> <span class="s1">&#39;U&#39;</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Down</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">row</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">newState</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
        <span class="nx">temp</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">col</span><span class="p">];</span>
        <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">empty</span><span class="p">;</span>
        <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">newState</span><span class="p">,</span> <span class="nx">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">newNode</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">depth</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">heuristic</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
            <span class="nx">newNode</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">path</span> <span class="o">+</span> <span class="s1">&#39;D&#39;</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Left</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">col</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">newState</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
        <span class="nx">temp</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">empty</span><span class="p">;</span>
        <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">newState</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">newNode</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">depth</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">heuristic</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
            <span class="nx">newNode</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">path</span> <span class="o">+</span> <span class="s1">&#39;L&#39;</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Right</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">col</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">newState</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
        <span class="nx">temp</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">empty</span><span class="p">;</span>
        <span class="nx">newState</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">newState</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">newNode</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">depth</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">heuristic</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
            <span class="nx">newNode</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">path</span> <span class="o">+</span> <span class="s1">&#39;R&#39;</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">newNode</span><span class="p">.</span><span class="nx">strRepresentation</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>这里的 <code>if</code> 条件语句都很像，差别只是他们针对的移动方向不同。首先，我们判断一下这步是否能够正常进行。比如向右移动，只有空滑块的列数小于网格的行数才行。如果这步能够正常移动，那么</p>

    </div>
</div>
<div class="card">
    <!-- 多说 start -->
    <div class="ds-thread" data-thread-key="/2016/02/05/javascript-ai-for-an-html-sliding-tiles-puzzle" data-title="用 Javascript 编写基于 HTML 的数字推盘游戏的 AI" data-url="/2016/02/05/javascript-ai-for-an-html-sliding-tiles-puzzle.html"></div>
    <script type="text/javascript" charset="utf-8" src="/js/duoshuo/duoshuo.js"></script>
    <!-- 多说  end  -->
</div>

    <a href="javascript:document.body.scrollIntoView(true)" class="card hover-top">
        <div class="content">
            <div class="date">© Copyright 2011 ~ 2016 by vivaxy</div>
        </div>
    </a>
</div>
</body>
<script type="text/javascript" src="/js/analysis/ba.js"></script>
</html>
